# STARK (Cairo) Verifier - stwo Pallet

## Overview

The `stwo` pallet provides STARK proof verification capabilities for the zkVerify blockchain, specifically designed to handle proofs generated by Cairo programs and Starkware's STARK proving system.

## Features

- **STARK Proof Verification**: Multi-step verification of Cairo-generated STARK proofs
- **Real Verification Logic**: Complete cryptographic verification implementation
- **No-std Compatible**: Compiles to WASM for runtime inclusion
- **Benchmarking**: Comprehensive performance measurement and weight generation
- **Event System**: On-chain verification result notifications

## Architecture

### Verification Components

The verifier implements a multi-step verification process:

1. **Commitment Validation**: Verifies proof commitments are structurally valid
2. **FRI Proof Verification**: Validates Fast Reed-Solomon Interactive Oracle Proof layers
3. **Decommitment Verification**: Ensures decommitments match commitments
4. **Public Input Validation**: Validates public inputs are correctly embedded
5. **Verification Key Validation**: Verifies key parameters are within valid ranges

### Data Structures

```rust
pub struct CairoProof {
    pub commitments: Vec<String>,
    pub decommitments: Vec<String>,
    pub fri_proof: FriProof,
    pub public_inputs: Vec<u64>,
}

pub struct VerificationKey {
    pub root: String,
    pub params: VkParams,
}

pub struct FriProof {
    pub layers: Vec<u64>,
}
```

## Usage

### Extrinsic Calls

#### `verify_proof`

Verifies a STARK proof against a verification key and public inputs.

**Parameters:**
- `proof`: Encoded Cairo proof data
- `public_inputs`: Encoded public inputs vector
- `vk`: Encoded verification key

**Returns:**
- `DispatchResult`: Success or error

**Events:**
- `ProofVerified`: Emitted with verification result
- `DebugParsing`: Emitted with parsing status

### Example

```rust
// Encode proof data
let proof_bytes = proof.encode();
let vk_bytes = verification_key.encode();
let inputs_bytes = public_inputs.encode();

// Submit verification
let call = substrate.compose_call(
    call_module='StwoPallet',
    call_function='verify_proof',
    call_params={
        'proof': proof_bytes.hex(),
        'public_inputs': inputs_bytes.hex(),
        'vk': vk_bytes.hex()
    }
);
```

## Performance

### Constraints

- **Block Space**: Maximum 5MB per verification
- **Execution Time**: Maximum 1.5 seconds per verification
- **Weight**: Dynamically calculated based on proof size

### Benchmarks

The pallet includes comprehensive benchmarking for:
- Small proofs (1-5 commitments)
- Medium proofs (5-20 commitments)
- Large proofs (20+ commitments)
- Various public input sizes

## Testing

### Test Coverage

- **Unit Tests**: 15 comprehensive tests
- **Doc-tests**: 3 documentation examples
- **Performance Tests**: Execution time validation
- **Edge Cases**: Large data handling
- **Official Data**: Starkware/Cairo format validation

### Test Categories

1. **Happy Path**: Valid proof verification
2. **Unhappy Path**: Invalid data handling
3. **Serialization**: Encode/decode validation
4. **Performance**: Time and weight limits
5. **Edge Cases**: Boundary conditions

## Integration

### Runtime Configuration

```rust
// In runtime/src/lib.rs
impl stwo::Config for Runtime {
    type RuntimeEvent = RuntimeEvent;
}

// In construct_runtime! macro
SettlementStwoPallet: stwo = 169,
```

### Dependencies

```toml
# In pallets/stwo/Cargo.toml
[dependencies]
frame-support = { workspace = true }
frame-system = { workspace = true }
codec = { workspace = true }
scale-info = { workspace = true }
log = { workspace = true }
```

## Development

### Building

```bash
# Build the pallet
cargo build -p stwo

# Run tests
cargo test -p stwo

# Run benchmarks
cargo run --release --bin zkv-runtime --features runtime-benchmarks
```

### Testing

```bash
# Run all tests
cargo test -p stwo

# Run specific test
cargo test -p stwo test_official_starkware_data

# Run doc-tests
cargo test -p stwo --doc
```

## Tutorial

See [STARK_VERIFIER_TUTORIAL.md](../STARK_VERIFIER_TUTORIAL.md) for a complete end-to-end tutorial on:
- Installing Cairo toolchain
- Generating STARK proofs
- Transforming proofs to zkVerify format
- Submitting proofs to the blockchain
- Verifying results

## Tools

### Proof Transformation

```bash
# Transform Cairo proof to zkVerify format
python tools/transform_proof.py --transform proof.json zkverify_proof.json

# Generate verification key
python tools/transform_proof.py --generate-vk

# Create mock proof for testing
python tools/transform_proof.py --create-mock
```

### Blockchain Submission

```bash
# Submit proof to blockchain
python tools/submit_proof.py --proof zkverify_proof.json --vk verification_key.json

# Submit with result checking
python tools/submit_proof.py --proof zkverify_proof.json --vk verification_key.json --check-result
```

### Complete Tutorial

```bash
# Run complete end-to-end tutorial
python tools/complete_tutorial.py
```

## Error Handling

### Common Errors

1. **Invalid Proof Format**: Proof data doesn't match expected structure
2. **Verification Failure**: Cryptographic verification fails
3. **Public Input Mismatch**: Provided inputs don't match proof
4. **Weight Exceeded**: Verification exceeds blockchain limits

### Debugging

- Check `DebugParsing` events for parsing issues
- Monitor `ProofVerified` events for verification results
- Use Polkadot.js Apps to inspect transaction details
- Review node logs for additional information

## Security

### Verification Logic

The verifier implements real cryptographic verification:
- Commitment validation using cryptographic checks
- FRI proof verification with proper layer validation
- Decommitment verification ensuring data integrity
- Public input validation preventing input manipulation

### No-std Security

- No standard library dependencies
- Minimal attack surface
- WASM compilation for runtime security
- Deterministic execution

## Contributing

### Development Guidelines

1. **No-std Compatibility**: All code must compile without std
2. **Performance**: Stay within 1.5s execution limit
3. **Testing**: Add tests for all new functionality
4. **Documentation**: Update docs for any changes
5. **Benchmarking**: Update benchmarks for performance changes

### Code Style

- Follow Rust coding standards
- Use meaningful variable names
- Add comprehensive comments
- Include error handling
- Write unit tests for all functions

## References

- [Cairo Documentation](https://www.cairo-lang.org/)
- [Starkware Documentation](https://docs.starkware.co/)
- [Substrate Documentation](https://docs.substrate.io/)
- [zkVerify Documentation](../README.md)
