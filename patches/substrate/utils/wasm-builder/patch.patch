diff -ruN '--exclude=*.patch' '--exclude=PATCH.md' '--exclude=rustfmt.toml' '--exclude=Cargo.toml' upstream/src/lib.rs patched/src/lib.rs
--- upstream/src/lib.rs
+++ patched/src/lib.rs
@@ -90,6 +90,9 @@
 //!   also be built. This is necessary to make sure the standard library crates only use the exact
 //!   WASM feature set that our executor supports. Enabled by default for RISC-V target and WASM
 //!   target (but only if Rust < 1.84). Disabled by default for WASM target and Rust >= 1.84.
+//! - `WASM_BUILD_LEGACY_TARGET` - If set to `1` or `true`, forces the use of `wasm32-unknown-unknown`
+//!   target instead of `wasm32v1-none` even on Rust >= 1.84. This is useful when some dependencies
+//!   don't properly support the stricter `wasm32v1-none` target.
 //! - `WASM_BUILD_CARGO_ARGS` - This can take a string as space separated list of `cargo` arguments.
 //!   It was added specifically for the use case of enabling JSON diagnostic messages during the
 //!   build phase, to be used by IDEs that parse them, but it might be useful for other cases too.
@@ -176,6 +179,10 @@
 /// during the build phase.
 const WASM_BUILD_CARGO_ARGS: &str = "WASM_BUILD_CARGO_ARGS";

+/// Environment variable to force the use of `wasm32-unknown-unknown` target instead of
+/// `wasm32v1-none` even on Rust >= 1.84.
+const WASM_BUILD_LEGACY_TARGET: &str = "WASM_BUILD_LEGACY_TARGET";
+
 /// The target to use for the runtime. Valid values are `wasm` (default) or `riscv`.
 const RUNTIME_TARGET: &str = "SUBSTRATE_RUNTIME_TARGET";

@@ -405,6 +412,11 @@
 	}
 }

+/// Return if the legacy target is forced via the environment variable
+fn is_forced_wasm_build_legacy_target() -> bool {
+	get_bool_environment_variable(crate::WASM_BUILD_LEGACY_TARGET).unwrap_or(false)
+}
+
 #[derive(Copy, Clone, PartialEq, Eq)]
 enum RuntimeTarget {
 	Wasm,
@@ -430,11 +442,19 @@
 		}
 	}

+	/// Returns true if we should use wasm32v1-none target for WASM builds.
+	fn should_use_wasm32v1_none(cargo_command: &CargoCommand) -> bool {
+		if is_forced_wasm_build_legacy_target() {
+			return false;
+		}
+		cargo_command.is_wasm32v1_none_target_available()
+	}
+
 	/// Figures out the target parameter value for rustc.
 	fn rustc_target(self, cargo_command: &CargoCommand) -> String {
 		match self {
 			RuntimeTarget::Wasm =>
-				if cargo_command.is_wasm32v1_none_target_available() {
+				if Self::should_use_wasm32v1_none(cargo_command) {
 					"wasm32v1-none".into()
 				} else {
 					"wasm32-unknown-unknown".into()
@@ -452,7 +472,7 @@
 	fn rustc_target_dir(self, cargo_command: &CargoCommand) -> &'static str {
 		match self {
 			RuntimeTarget::Wasm =>
-				if cargo_command.is_wasm32v1_none_target_available() {
+				if Self::should_use_wasm32v1_none(cargo_command) {
 					"wasm32v1-none".into()
 				} else {
 					"wasm32-unknown-unknown".into()
@@ -463,20 +483,11 @@

 	/// Figures out the build-std argument.
 	fn rustc_target_build_std(self, cargo_command: &CargoCommand) -> Option<&'static str> {
-		if !crate::get_bool_environment_variable(crate::WASM_BUILD_STD).unwrap_or_else(
-			|| match self {
-				RuntimeTarget::Wasm => !cargo_command.is_wasm32v1_none_target_available(),
-				RuntimeTarget::Riscv => true,
-			},
-		) {
-			return None;
+		match (crate::get_bool_environment_variable(crate::WASM_BUILD_STD), self) {
+			(Some(false), _) => None, // Explicitly disabled
+			(_, RuntimeTarget::Wasm) if Self::should_use_wasm32v1_none(cargo_command) => None, // wasm32v1-none has MVP features built-in
+			(_, RuntimeTarget::Wasm) => Some("build-std"), // Legacy wasm32-unknown-unknown
+			_ => Some("build-std=core,alloc"), // RISC-V or explicit WASM_BUILD_STD=1
 		}
-
-		// This is a nightly-only flag.
-
-		// We only build `core` and `alloc` crates since wasm-builder disables `std` featue for
-		// runtime. Thus the runtime is `#![no_std]` crate.
-
-		Some("build-std=core,alloc")
 	}
 }
diff -ruN '--exclude=*.patch' '--exclude=PATCH.md' '--exclude=rustfmt.toml' '--exclude=Cargo.toml' upstream/src/prerequisites.rs patched/src/prerequisites.rs
--- upstream/src/prerequisites.rs
+++ patched/src/prerequisites.rs
@@ -15,7 +15,7 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.

-use crate::{write_file_if_changed, CargoCommand, CargoCommandVersioned, RuntimeTarget};
+use crate::{is_forced_wasm_build_legacy_target, write_file_if_changed, CargoCommand, CargoCommandVersioned, RuntimeTarget};

 use console::style;
 use std::{
@@ -268,8 +268,9 @@
 	}

 	if cargo_command.supports_wasm32v1_none_target() &&
-		!cargo_command.is_wasm32v1_none_target_installed()
-	{
+			!cargo_command.is_wasm32v1_none_target_installed() &&
+			!is_forced_wasm_build_legacy_target()
+		{
 		build_helper::warning!("You are building WASM runtime using `wasm32-unknown-unknown` target, although Rust >= 1.84 supports `wasm32v1-none` target!");
 		build_helper::warning!("You can install it with `rustup target add wasm32v1-none --toolchain {toolchain}` if you're using `rustup`.");
 		build_helper::warning!("After installing `wasm32v1-none` target, you must rebuild WASM runtime from scratch, use `cargo clean` before building.");
diff -ruN '--exclude=*.patch' '--exclude=PATCH.md' '--exclude=rustfmt.toml' '--exclude=Cargo.toml' upstream/src/wasm_project.rs patched/src/wasm_project.rs
--- upstream/src/wasm_project.rs
+++ patched/src/wasm_project.rs
@@ -872,8 +872,10 @@
 			// Also see:
 			// https://blog.rust-lang.org/2024/09/24/webassembly-targets-change-in-default-target-features.html#disabling-on-by-default-webassembly-proposals

-			if !cargo_cmd.is_wasm32v1_none_target_available() {
-				rustflags.push_str("-C target-cpu=mvp ");
+			// zkVerify patch: Add -C target-cpu=mvp when using legacy wasm32-unknown-unknown target
+			// This disables post-MVP WASM features that cause UnknownOpcode errors
+			if target.rustc_target(&cargo_cmd) == "wasm32-unknown-unknown" {
+				rustflags.push_str("-C target-cpu=mvp -C target-feature=-sign-ext ");
 			}

 			rustflags.push_str("-C link-arg=--export-table ");
